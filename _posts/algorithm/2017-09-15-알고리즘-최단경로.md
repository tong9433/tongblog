---
layout: default
title:  "최단경로"
date:   2017-10-03
categories: "알고리즘"
---

# 알고리즘 - 최단경로 (벨만포드, 다익스트라)
* 벨만포드 : 음수가중치가 있는 경우.
* 다익스트라 : 일반적인 최단 경로 문제 (양수가중치).
* BFS : 트리나 가중치가 1인 경우.

<br>
## 벨만포드
* `dist[i]`라는 배열을 만들고 시작점에서 i로 가는 최단 경로를 저장하자.
* 모든 간선에 대하여 `dist[v] = Min(dist[v], dist[u]+c` 를 검사한다.
* 이와 같은 과정을 노드가 `N`개일 경우 `N-1`번 반복한다.
* 시간복잡도 : O(VE)
* E<=V^2 이므로 O(V^3) 정도임.
* 가중치가 음수가 있는 경우에도 사용 가능.

* Ex) Backjoon11657 타임머신 문제

```java

import java.util.ArrayList;
import java.util.Scanner;

class Edge{

    int start;
    int end;
    int cost;

    Edge(){
        this.start=0;
        this.end=0;
        this.cost=0;

    }

    Edge(int s, int e, int c){
        this.start = s;
        this.end = e;
        this.cost = c;
    }

}

public class Main {

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();
        int inf = Integer.MAX_VALUE;

        ArrayList<Edge> a = new ArrayList<>();
        int[] dist = new int[n+1];

        for(int i=1; i<n+1; i++){
            dist[i] = inf;
        }



        for(int i=0; i<m; i++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int c = sc.nextInt();

            a.add(new Edge(x,y,c));
        }

        dist[1] = 0;

        boolean cycle = false;

        for(int i=1;i<=n;i++){
            for(Edge e : a){
                int x = e.start;
                int y = e.end;
                int c = e.cost;
                if(dist[x] != inf && dist[y]>dist[x]+c) {
                    dist[y] = dist[x] + c;
                    if (i == n) {//음수 사이클이 존재한 다는 의미
                        cycle = true;
                    }
                }
            }
        }

        if(cycle){
            System.out.println(-1);
        }else{
            for(int i=2; i<=n; i++) {
                if (dist[i] == inf) dist[i] = -1;
                System.out.println(dist[i]);
            }
        }

    }
}

```

* Ex) Backjoon1865 웜홀 문제
* 문제내에서 직접적으로 음수가중치를 언급하진 않지만 웜홀 자체가 음수 간선임을 알아챌 수 있음.

```java

import java.util.ArrayList;
import java.util.Scanner;

class Edge{

    int start;
    int end;
    int cost;

    Edge(){
        this.start=0;
        this.end=0;
        this.cost=0;

    }

    Edge(int s, int e, int c){
        this.start = s;
        this.end = e;
        this.cost = c;
    }

}

public class Main {

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int t = sc.nextInt();
        int inf = Integer.MAX_VALUE;

        for(int k=0; k<t; k++){
            int n = sc.nextInt();
            int m = sc.nextInt();
            int w = sc.nextInt();

            ArrayList<Edge> a = new ArrayList<>();

            for(int i=0; i<m; i++){
                int s = sc.nextInt();
                int e = sc.nextInt();
                int c = sc.nextInt();

                a.add(new Edge(s,e,c));
                a.add(new Edge(e,s,c));
            }

            for(int i=0; i<w; i++){
                int x = sc.nextInt();
                int y = sc.nextInt();
                int z = sc.nextInt();//줄어드는 시간
                a.add(new Edge(x,y,-1*z)); // 하나의 음수가중치의 간선이라고 생각하자.
            }

            int[] dist = new int[n+1];
            for(int i=1; i<=n; i++) {
                dist[i] = inf;
            }

            dist[1]=0;

            boolean cycle = false;

            for(int i=1; i<=n; i++){
                for(Edge e : a){
                    int x = e.start;
                    int y = e.end;
                    int z = e.cost;
                    if(dist[x]!=inf&&dist[y]>dist[x]+z){
                        dist[y] = dist[x]+z;
                        if(i==n){
                            cycle=true;
                        }

                    }
                }
            }

            if(cycle){
                System.out.println("YES");
            }else{
                System.out.println("NO");
            }

        }
    }

}

```


<br>
## 다익스트라
* `dist[i]`라는 배열과 `check[i]`라는 배열이 필요함.
* `check[i]=i`가 체크되어 있으면 `true`, 아닐 경우 `false`를 해줌.
* `V^2` 시간복잡도가 걸림.
* 방법
1. 체크되어 있지 않은 정점 중에서 dist의 값이 가장 작은 정점 V를 선택한다.
2. V를 체크한다
3. V와 연결된 모든 정점을 검사함.
4. 간선(출발,도착,비용)을 `(x,y,z)`라 할 때 `dist[y] > dist[x] + z`이면 `dist[y] = dist[x] + z` 로 갱신
5. 1~4 까지 모든 정점이 체크 될 때 까지 계속 진행

* 예제 Baekjoon 11770 최소비용, 경로 구하기 문제

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Baekjoon1916_다익스트라 {

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();
        int inf = 1000000000;

        int[] dist = new int[n+1];
        boolean[] check = new boolean[n+1]; // 방문한 노드인지 아닌지 체크
        int[] v = new int[n+1]; // 경로를 입력

        List<Edge>[] a = (List<Edge>[])new List[n+1];

        for(int i=1; i<=n; i++){
            a[i] = new ArrayList<>();
            check[i] = false;
            dist[i] = inf;
        }


        for(int i=0; i<m; i++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int c = sc.nextInt();

            a[x].add(new Edge(x,y,c));
        }


        int start = sc.nextInt();
        int end = sc.nextInt();

        dist[start] = 0;
        v[start] = -1;

        for(int k=0;k<n-1;k++){
            //노드중 dist가 가장 낮은 값 찾기
            int j = inf +1;
            int x = -1;
            for(int i=1; i<=n; i++){
                if(!check[i] && j>dist[i]){
                    j = dist[i];
                    x = i;
                }
            }

            check[x] = true;
            for(Edge y : a[x]){
                if(dist[y.end]>dist[x]+y.cost){
                    dist[y.end] = dist[x]+y.cost;
                    v[y.end] = x;
                }
            }
        }

        System.out.println(dist[end]);

        //경로 출력하기

        Stack<Integer> s = new Stack<Integer>();
        int x = end;
        while(x!= -1){
            s.push(x);
            x = v[x];
        }

        System.out.println(s.size());

        while(!s.empty()){
            System.out.print(s.pop()+" ");
        }

    }
}


```

* 예제 Baekjoon 1504 특정 경로를 지나쳐야 하는 문제.
* 노드 `V1`과 `V2`를 거쳐서 가는 최단 경로를 찾는 경우 `1->V1`,`V1->V2`,`V2->n`의 경우와 `1->V2`,`V2->V1`,`V1->n` 중
더 적게 걸리는 것을 반환 하며 풀기.
* 인접행렬을 이용해서 풀어보자.

```java
import java.util.*;
public class Main {
    static final int inf = 100000000;
    private static int[] dijkstra(int n, int[][] a, int start) {
        int[] d = new int[n+1];
        boolean[]c = new boolean[n+1];
        for (int i=1; i<=n; i++) {
            d[i] = inf;
            c[i] = false;
        }
        d[start] = 0;
        for (int k=0; k<n-1; k++) {
            int min = inf+1;
            int x = -1;
            for (int i=1; i<=n; i++) {
                if (c[i] == false && min > d[i]) {
                    min = d[i];
                    x = i;
                }
            }
            c[x] = true;
            for (int i=1; i<=n; i++) {
                if (d[i] > d[x] + a[x][i]) {
                    d[i] = d[x] + a[x][i];
                }
            }
        }
        return d;
    }
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][]a = new int[n+1][n+1];
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=n; j++) {
                a[i][j] = inf;
            }
        }
        int m = sc.nextInt();
        for (int i=0; i<m; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int z = sc.nextInt();
            if (a[x][y] > z) {
                a[x][y] = z;
            }
            if (a[y][x] > z) {
                a[y][x] = z;
            }
        }
        int v1 = sc.nextInt();
        int v2 = sc.nextInt();
        int[] dstart = dijkstra(n,a,1);
        int[] d1 = dijkstra(n,a,v1);
        int[] d2 = dijkstra(n,a,v2);
        int ans = dstart[v1] + d1[v2] + d2[n];
        int ans2 = dstart[v2] + d2[v1] + d1[n];
        if (ans > ans2) {
            ans = ans2;
        }
        if (ans >= inf) {
            ans = -1;
        }
        System.out.println(ans);
    }
}
```

<br>
## 플로이드
* 가장 쉽고 빠르게 구현이 가능하다.
* 모든 쌍의 최단 경로를 구하는 알고리즘임.

```java
for (int k=1; k<=n; k++) {
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) {
            if (d[i][j] > d[i][k] + d[k][j]) {
                d[i][j] = d[i][k] + d[k][j];
            }
        }
    }
}
```

* 위 코드로 구현이 가능.
* O(V^3)의 시간복잡도이므로 효율적이진 않음.
* `1~n`까지의 정점이 있을 때 `d[k][i][j]`를 `i->j`를 이동하는 최단 경로
* 중간에 방문할 수 있는 정점은 `1~k`
* k가 경로에 없는 경우 `d[k-1][i][j]`
* k가 경로에 있는 경우 `d[k-1][i][k]+d[k-1][k][j]` 로 쉽게 구할 수 있음
* ex) Baekjoon11403 문제, 가중치가 없는 방향 그래프에서 연결 여부 찾기

```java
import java.util.Scanner;

public class Baekjoon11403_경로찾기_플로이드 {

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        int[][] dist = new int[n][n];

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                dist[i][j] = sc.nextInt();
            }
        }


        //k,i,j의 위치에 주의할 것, 이 경우는 가중치가 없고 연결됨을 파악하는 문제이므로 if문의 조건을 다음과 같이함.
        for(int k=0; k<n; k++){
            for(int i=0; i<n; i++){
                for(int j=0; j<n; j++){
                    if(dist[i][k]==1 && dist[k][j]==1){
                        dist[i][j] = 1;
                    }
                }
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){

                System.out.print(dist[i][j]);
                System.out.print(" ");

            }
            System.out.println();
        }


    }


}

```

* ex) Baekjoon11404 플로이드 문제

```java
import java.util.Scanner;

public class Baekjoon11404_플로이드 {

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        int[][] dist = new int[n][n];
        int inf=Integer.MAX_VALUE;

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                dist[i][j] = inf;
            }
        }

        for(int i=0; i<m; i++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int cost= sc.nextInt();
            if(dist[x-1][y-1]==inf||cost<dist[x-1][y-1]){
                dist[x-1][y-1] = cost;
            }
        }
        //k,i,j의 위치에 주의할 것, 이 경우는 가중치가 없고 연결됨을 파악하는 문제이므로 if문의 조건을 다음과 같이함.
        for(int k=0; k<n; k++){
            for(int i=0; i<n; i++){
                for(int j=0; j<n; j++){
                    if(i!=j && j!=k &&k!=i) {
                        if (dist[i][k] != inf && dist[k][j] != inf && dist[i][j] > dist[i][k] + dist[k][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(dist[i][j]==inf){
                    System.out.print("0");
                    System.out.print(" ");
                }
                else{
                    System.out.print(dist[i][j]);
                    System.out.print(" ");
                }

            }
            System.out.println();
        }

    }


}

```